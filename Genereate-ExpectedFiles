param(
    [datetime]$TargetDate = (Get-Date),
    [string]  $ExcelPath  = '\\autobot\fdrive\ishd\IS File List.xlsx'
)

# --- Read Excel (ImportExcel if available; else COM) ---
function Read-ExcelRows {
    param([string]$Path)
    if (Get-Module -ListAvailable -Name ImportExcel) {
        return Import-Excel -Path $Path -Worksheet 1
    }

    $excel = New-Object -ComObject Excel.Application
    $excel.Visible = $false
    try {
        $wb = $excel.Workbooks.Open($Path)
        $ws = $wb.Worksheets.Item(1)
        $values = $ws.UsedRange.Value2
        if (-not $values) { return @() }

        $rows=@(); $headers=@()
        for ($c=1; $c -le $values.GetLength(1); $c++) { $headers += [string]$values[1,$c] }
        for ($r=2; $r -le $values.GetLength(0); $r++) {
            $o=[ordered]@{}
            for ($c=1; $c -le $headers.Count; $c++) { $o[$headers[$c-1]] = $values[$r,$c] }
            if ($o.Values -ne $null -and ($o.Values -join '') -ne '') { $rows += [pscustomobject]$o }
        }
        $rows
    }
    finally {
        if ($wb) { $wb.Close($false) | Out-Null }
        $excel.Quit() | Out-Null
        [void][Runtime.InteropServices.Marshal]::ReleaseComObject($excel)
    }
}

if (-not (Test-Path $ExcelPath)) { throw "Excel file not found: $ExcelPath" }
$rows = Read-ExcelRows -Path $ExcelPath
if (-not $rows) { Write-Warning "No rows found."; return }

# --- Header resolution (forgiving) ---
function Normalize-Header([string]$s){ ($s -replace '[^a-z0-9]','').ToLower() }
$first = $rows | Select-Object -First 1
$normToActual=@{}
foreach($p in $first.PSObject.Properties.Name){
    $n=Normalize-Header $p
    if(-not $normToActual.ContainsKey($n)){ $normToActual[$n]=$p }
}
function ResolveCol([string[]]$cand){
    foreach($c in $cand){ $nc=Normalize-Header $c; if($normToActual.ContainsKey($nc)){ return $normToActual[$nc] } }
    $null
}

$colFileName = ResolveCol @('FileName','File Name','ExpectedFile','Expected File Name','SourceFileName','Source File Name')
$colFreq     = ResolveCol @('ExpectedFrequency','Frequency','Freq','Schedule','Cadence')
$colDay      = ResolveCol @('ExpectedDay','Day','DoW','Weekday','Week Day')
$colTime     = ResolveCol @('ExpectedTime','Time','ETA','DueTime','Due Time','TargetTime','Target Time')

function Get-ColVal($row,[string]$colName){
    if([string]::IsNullOrWhiteSpace($colName)){ return $null }
    $prop = $row.PSObject.Properties[$colName]
    if($prop){ return $prop.Value }
    $null
}

# --- Day token normalization ---
# Treat these as "All": all, *, any, undetermined, unknown, tbd, na/n/a (any spacing/case).
function Normalize-DayToken([string]$s){
    if([string]::IsNullOrWhiteSpace($s)){ return $null }      # blank stays null
    $t = $s.Trim()
    if ($t -match '^(all|\*|any|undetermined|unknown|tbd|n/?a)$') { return 'All' }

    switch (($t.Substring(0,[Math]::Min(3,$t.Length))).ToLower()){
        'mon'{'Mon'} 'tue'{'Tue'} 'wed'{'Wed'} 'thu'{'Thu'} 'fri'{'Fri'} 'sat'{'Sat'} 'sun'{'Sun'}
        default { $t }  # e.g., numeric day for monthly
    }
}

# --- Include logic (now: 'All' applies to ANY frequency) ---
function Should-Include($row,[datetime]$date){
    $freq = ([string](Get-ColVal $row $colFreq)).Trim().ToLower()
    $dayRaw = [string](Get-ColVal $row $colDay)
    $token  = Normalize-DayToken $dayRaw

    # If token is 'All' (includes 'Undetermined', 'TBD', etc.), include regardless of frequency
    if ($token -eq 'All') { return $true }

    switch($freq){
        'daily'   { return [string]::IsNullOrWhiteSpace($token) }                # blank/empty day â†’ include
        'weekly'  { return $token -eq $date.ToString('ddd') }
        'monthly' {
            $n=0
            if([int]::TryParse($dayRaw,[ref]$n)){ return ($n -gt 0 -and $n -eq $date.Day) }
            $false
        }
        default   { $false }
    }
}

# --- Time formatting (keeps original header name) ---
function Format-Time($val){
    if ($null -eq $val -or $val -eq '') { return '' }
    if ($val -is [double]) { return ([datetime]'1899-12-30').AddDays($val).ToString('HH:mm') }
    try { (Get-Date -Date $val).ToString('HH:mm') } catch { [string]$val }
}

# --- Build expected list (Date + all original headers; time normalized in-place; no ResolvedFileName) ---
$expected = foreach($r in $rows){
    if(-not (Get-ColVal $r $colFileName)){ continue }
    if(Should-Include $r $TargetDate){
        $out=[ordered]@{ Date = $TargetDate.ToString('yyyy-MM-dd') }
        foreach($p in $r.PSObject.Properties){
            if ($p.Name -eq 'ResolvedFileName') { continue }  # never include
            if ($colTime -and $p.Name -eq $colTime) {
                $out[$p.Name] = Format-Time (Get-ColVal $r $colTime)
            } else {
                $out[$p.Name] = $p.Value
            }
        }
        [pscustomobject]$out
    }
}

# --- Display and export ---
$expected | Format-Table -AutoSize
$expected | Export-Csv -NoTypeInformation -Encoding UTF8 -Path "\\autobot\fdrive\ishd\ExpectedFiles_$($TargetDate.ToString('yyyyMMdd')).csv"
